<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Metrikker og afstand – afstandudfradata</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Metrikker og afstand</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="afstande-udfra-data" class="level1 unnumbered">
<h1 class="unnumbered">Afstande udfra data</h1>
<p>Hvis data består af vægt og højde for nogen personer, er det ikke klart, hvad afstanden mellem to punkter <span class="math inline">\((v_1,h_1)\)</span> og <span class="math inline">\((v_2,h_2)\)</span> skal være. Altså, hvornår to punkter ligger tæt på hinanden.</p>
<p>[[ex:enheder og afstand]]{#ex:enheder og afstand label=“ex:enheder og afstand”} Tre personer er givet som datapunkter (vægt, højde) <span class="math inline">\(A=(70 kg, 165 cm)\)</span>, <span class="math inline">\(B=(90 kg, 180 cm)\)</span>, <span class="math inline">\(C=(80 kg, 190 cm)\)</span>.</p>
<p>Bruger vi Pythagoras på tallene, der står her, er afstanden mellem <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> <span class="math inline">\(\sqrt{20^2+15^2}=25\)</span>. Afstanden mellem <span class="math inline">\(A\)</span> og <span class="math inline">\(C\)</span> er <span class="math inline">\(\sqrt{10^2+25^2}=\sqrt{725}\simeq 27\)</span> og mellem <span class="math inline">\(B\)</span> og <span class="math inline">\(C\)</span> <span class="math inline">\(\sqrt{10^2+10^2}=\sqrt{200}\simeq 14\)</span>. Der er altså længst fra <span class="math inline">\(A\)</span> til <span class="math inline">\(C\)</span>.</p>
<p>Skifter vi enhed og udtrykker højden i meter <span class="math inline">\(A=(70 kg, 1,\!65 m)\)</span>, <span class="math inline">\(B=(90 kg, 1,\!80 m)\)</span>, <span class="math inline">\(C=(80 kg, 1,\!90 m)\)</span> er afstanden mellem <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> cirka 20. Mellem <span class="math inline">\(A\)</span> og <span class="math inline">\(C\)</span> cirka <span class="math inline">\(4\)</span> og mellem <span class="math inline">\(B\)</span> og <span class="math inline">\(C\)</span> cirka <span class="math inline">\(10\)</span>. Der er nu længst fra <span class="math inline">\(A\)</span> til <span class="math inline">\(B\)</span>.</p>
<p>Det er ikke ret smart. Skal man finde de nærmeste naboer, er svaret tilsyneladende som vinden blæser.</p>
<p>Selv hvis begge variable er i samme enhed, kan Pythagoras brugt med hovedet under armen være uheldigt:</p>
<p>Vi har data for, hvor meget familierne <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> og <span class="math inline">\(C\)</span> bruger på bolig og på mælk om måneden. Begge variable kan være i kroner. Hvis <span class="math inline">\(A\)</span> bruger <span class="math inline">\((7.500 kr, 200 kr)\)</span> (altså 7.500 kr på bolig og 200 kr på mælk) og <span class="math inline">\(B\)</span> bruger <span class="math inline">\((7.500 kr, 1.700 kr)\)</span>, mens <span class="math inline">\(C\)</span> bruger <span class="math inline">\((6.000 kr, 200 kr)\)</span>, er afstanden udregnet med Pythagoras den samme fra <span class="math inline">\(A\)</span> til <span class="math inline">\(B\)</span> som fra <span class="math inline">\(A\)</span> til <span class="math inline">\(C\)</span>, men vi vil nok mene, <span class="math inline">\(B\)</span> afviger mere fra <span class="math inline">\(A\)</span> end <span class="math inline">\(C\)</span> gør, fordi mælkeforbruget i familie <span class="math inline">\(B\)</span> er usædvanligt.</p>
<p>Har vi data for mange familier, kan vi kvantificere ideen om, hvad der er usædvanligt og bruge det til at lave en mere passende afstand.</p>
<section id="første-naive-tilgang---min-max-skalering" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="første-naive-tilgang---min-max-skalering">Første naive tilgang - Min-Max-skalering:</h2>
<p>Data er punkter <span class="math inline">\((x_i,y_i)\)</span> i planen. <span class="math inline">\(x\)</span>-værdierne ligger mellem <span class="math inline">\(a\)</span> og <span class="math inline">\(b\)</span>, mens <span class="math inline">\(y\)</span>-værdierne ligger mellem <span class="math inline">\(c\)</span> og <span class="math inline">\(d\)</span>. TEGNING af datapunkter.</p>
<p>Ideen er nu, at vi skalerer, så afstandene langs <span class="math inline">\(x\)</span>-aksen får samme vægt som afstande langs <span class="math inline">\(y\)</span>-aksen.</p>
<p>Afstand fra <span class="math inline">\((x_1,y_1)\)</span> til <span class="math inline">\((x_2,y_2)\)</span> er <span class="math inline">\(\sqrt{(\frac{x_2-x_1}{b-a})^2+(\frac{y_2-y_1}{d-c})^2}\)</span></p>
<p>Overvej, at man får samme effekt, samme afstand, hvis man erstatter hver punkt <span class="math inline">\((x_i,y_i)\)</span> med med <span class="math display">\[(x_i,y_i)_{Norm}=\left(\frac{x_i-a}{b-a}, \frac{y_i-c}{d-c}\right)\]</span></p>
</section>
<section id="mindre-naivt-mere-bøvlet.-feature-scaling." class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="mindre-naivt-mere-bøvlet.-feature-scaling.">Mindre naivt, mere bøvlet. Feature scaling.</h2>
<p>Skalering langs akserne, hvor man bruger data til at bestemme skaleringen, kaldes også "feature scaling", når vi arbejder med perceptroner eller neurale netværk. Hvis det data, der skal læres fra - træningsdata - er <span class="math inline">\((x_1,y_1), (x_2,y_2),\ldots, (x_n,y_n)\)</span>, så skalerer vi langs førsteaksen ved</p>
<ol type="1">
<li><p>Udregn et estimat for middelværdien af <span class="math inline">\(x\)</span>: <span class="math display">\[\bar{x}=\frac{\Sigma_{i=1}^nx_i}{n}\]</span></p></li>
<li><p>og et estimat for denne variabels spredning: <span class="math display">\[s_x=\sqrt{\frac{\Sigma_{i=1}^n(x_i-\bar{x})^2}{n-1}}\]</span></p></li>
</ol>
<p>Feature scaling af <span class="math inline">\(x_i\)</span> er da <span class="math display">\[\hat{x}_i=\frac{x_i-\bar{x}}{s_x}\]</span> Tilsvarende estimeres middelværdi og spredning for <span class="math inline">\(y\)</span> og feature scaling udregnes <span class="math display">\[\hat{y}_i= \frac{y_i-\bar{y}}{s_y}\]</span></p>
<p>Euklidisk afstand mellem disse nye punkter <span class="math inline">\((\hat{x}_i,\hat{y}_i)\)</span> og <span class="math inline">\((\hat{x}_j,\hat{y}_j)\)</span> er</p>
<p><span class="math display">\[\sqrt{\left(\frac{x_i-\bar{x}}{s_x}-\frac{x_j-\bar{x}}{s_x}\right)^2 +\left(\frac{y_i-\bar{y}}{s_y}-\frac{y_j-\bar{y}}{s_y}\right)^2}=\sqrt{\left(\frac{x_i-x_j}{s_x}\right)^2+\left(\frac{y_i-y_j}{s_y}\right)^2}\]</span></p>
<p>Hvis vi sammenligner med den naive tilgang, er den ikke helt skæv. Der skal bare skaleres med <span class="math inline">\(s_x\)</span> i stedet for <span class="math inline">\(b-a\)</span> og med <span class="math inline">\(s_y\)</span> i stedet for <span class="math inline">\(c-d\)</span>.</p>
<p>SKAL HER STÅ NOGET OM, AT DET ER STANDARDISERING OG Z-score??</p>
<p>Se på INTERAKTIV ILLUSTRATION. Hvad er forskellen på den naive tilgang og <em>feature scaling</em> i disse tilfælde?</p>
<p>Vis, at afstandene i såvel den naive, som den knap så naive tilgang giver metrikker. VINK: De er begge skaleringer, så man kan gøre det i et hug.</p>
<p>Kan vi finde noget om middelværdi og spredning for eksemplerne med vægt, højde og det med bolig og mælk? Eller måske give 10 punkter? Det gennemsnitlige forbrug af mælk pr husstand pr år er ca. 1300 kr iflg statbank.dk Årlig lejeudgift er i gennemsnit 31.619 kr (Faktisk husleje betalt af lejere) men der er forbrugsudgifter - vand, fjernvarme,... på ca.28.000 oveni.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>